import pandas as pd
import random
import string
import openpyxl
from openpyxl import load_workbook
import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import datetime
import logging
from typing import List, Dict, Optional, Tuple
from main.config import DATABASE_CONFIG, APP_CONFIG

# 設置日誌
logging.basicConfig(level=getattr(logging, APP_CONFIG['log_level']))
logger = logging.getLogger(__name__)

class SalesDataUploader:
    def __init__(self):
        """初始化數據上傳器"""
        self.db_config = DATABASE_CONFIG
        self.connection = None
        
        # 這個模組專用的表配置
        self.table_config = {
            'order_transactions': 'order_transactions',
            'product_master': 'product_master'
        }
        
    def connect_database(self):
        """連接數據庫"""
        try:
            self.connection = psycopg2.connect(
                host=self.db_config.host,
                port=self.db_config.port,
                database=self.db_config.database,
                user=self.db_config.username,
                password=self.db_config.password,
                connect_timeout=APP_CONFIG['timeout']
            )
            logger.info("數據庫連接成功")
            return True
        except Exception as e:
            logger.error(f"數據庫連接失敗: {str(e)}")
            return False
    
    def close_connection(self):
        """關閉數據庫連接"""
        if self.connection:
            self.connection.close()
            logger.info("數據庫連接已關閉")
    
    def delete_records_by_month(self, year: int, month: int) -> int:
        """
        刪除指定年月的記錄
        
        Args:
            year (int): 年份，例如 2025
            month (int): 月份，例如 3
            
        Returns:
            int: 刪除的記錄數量
        """
        try:
            with self.connection.cursor() as cursor:
                query = f"""
                DELETE FROM {self.table_config['order_transactions']}
                WHERE EXTRACT(YEAR FROM transaction_date) = %s 
                  AND EXTRACT(MONTH FROM transaction_date) = %s
                """
                cursor.execute(query, (year, month))
                deleted_count = cursor.rowcount
                self.connection.commit()
                
                logger.info(f"刪除了 {deleted_count} 筆 {year}年{month}月 的記錄")
                return deleted_count
                
        except Exception as e:
            self.connection.rollback()
            logger.error(f"刪除 {year}年{month}月 記錄失敗: {str(e)}")
            raise
    
    def extract_months_from_data(self, data: List[Dict]) -> set:
        """
        從數據中提取所有涉及的年月
        
        Args:
            data (list): 交易記錄列表
            
        Returns:
            set: 包含 (年份, 月份) 元組的集合
        """
        months = set()
        
        for record in data:
            transaction_date = record['transaction_date']
            if transaction_date:
                # 處理不同的日期格式
                if isinstance(transaction_date, str):
                    # 如果是字符串，嘗試解析
                    try:
                        date_obj = datetime.strptime(transaction_date, '%Y-%m-%d').date()
                    except ValueError:
                        try:
                            date_obj = datetime.strptime(transaction_date, '%Y/%m/%d').date()
                        except ValueError:
                            logger.warning(f"無法解析日期格式: {transaction_date}")
                            continue
                elif hasattr(transaction_date, 'year') and hasattr(transaction_date, 'month'):
                    # 如果已經是日期對象
                    date_obj = transaction_date
                else:
                    logger.warning(f"未知日期格式: {transaction_date}")
                    continue
                
                months.add((date_obj.year, date_obj.month))
        
        return months
    
    def delete_records_by_months(self, months: set) -> int:
        """
        刪除多個年月的記錄
        
        Args:
            months (set): 包含 (年份, 月份) 元組的集合
            
        Returns:
            int: 刪除的記錄總數
        """
        if not months:
            return 0
            
        total_deleted = 0
        
        try:
            for year, month in months:
                with self.connection.cursor() as cursor:
                    query = f"""
                    DELETE FROM {self.table_config['order_transactions']}
                    WHERE EXTRACT(YEAR FROM transaction_date) = %s 
                      AND EXTRACT(MONTH FROM transaction_date) = %s
                    """
                    cursor.execute(query, (year, month))
                    deleted_count = cursor.rowcount
                    total_deleted += deleted_count
                    
                    logger.info(f"刪除了 {deleted_count} 筆 {year}年{month}月 的記錄")
            
            self.connection.commit()
            logger.info(f"總共刪除了 {total_deleted} 筆記錄")
            return total_deleted
                
        except Exception as e:
            self.connection.rollback()
            logger.error(f"刪除月份記錄失敗: {str(e)}")
            raise
    
    def generate_unique_transaction_id(self) -> str:
        """
        生成唯一的 8 位數字+小寫英文 transaction_id
        格式: 8位隨機字符 (數字+小寫字母) 例如: a1b2c3d4
        
        Returns:
            str: 唯一的 transaction_id
        """
        max_attempts = 100  # 最大嘗試次數，避免無限循環
        
        for attempt in range(max_attempts):
            # 生成 8 位隨機字符（數字+小寫字母）
            transaction_id = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
            
            # 檢查是否已存在
            if not self.transaction_id_exists(transaction_id):
                return transaction_id
                
            logger.debug(f"Transaction ID {transaction_id} 已存在，重新生成 (嘗試 {attempt + 1})")
        
        # 如果多次嘗試仍然重複，使用時間戳確保唯一性
        timestamp = str(int(datetime.now().timestamp()))[-8:]  # 取時間戳後8位
        fallback_id = timestamp
        logger.warning(f"使用備用 transaction_id: {fallback_id}")
        return fallback_id
    
    def transaction_id_exists(self, transaction_id: str) -> bool:
        """
        檢查 transaction_id 是否已存在
        
        Args:
            transaction_id (str): 要檢查的 transaction_id
            
        Returns:
            bool: 如果已存在返回 True，否則返回 False
        """
        try:
            with self.connection.cursor() as cursor:
                query = f"""
                SELECT EXISTS(
                    SELECT 1 FROM {self.table_config['order_transactions']}
                    WHERE transaction_id = %s
                )
                """
                cursor.execute(query, (transaction_id,))
                return cursor.fetchone()[0]
                
        except Exception as e:
            logger.error(f"檢查 transaction_id 存在性失敗: {str(e)}")
            return True  # 出錯時保守處理，假設已存在
    
    def parse_sales_data(self, file_path: str) -> List[Dict]:
        """
        解析 3月銷貨.xlsx 文件，提取交易數據
        
        Args:
            file_path (str): Excel 文件路徑
        
        Returns:
            list: 包含所有交易記錄的列表
        """
        logger.info(f"開始解析文件: {file_path}")
        
        # 使用 openpyxl 讀取 Excel 文件
        workbook = load_workbook(file_path, data_only=True)
        worksheet = workbook.active
        
        logger.info(f"工作表名稱: {worksheet.title}")
        logger.info(f"數據範圍: {worksheet.calculate_dimension()}")
        
        # 獲取最大行數和列數
        max_row = worksheet.max_row
        max_col = worksheet.max_column
        
        logger.info(f"總行數: {max_row}, 總列數: {max_col}")
        
        # 數據從第8行開始
        data = []
        
        # 用於向前填充的變量
        current_customer_id = ''
        current_product_id = ''
        current_product_name = ''
        current_currency = ''
        
        # 遍歷從第8行開始的所有行
        for row in range(8, max_row + 1):
            # 獲取各列的值
            customer_id_cell = worksheet.cell(row=row, column=1).value    # A列
            product_id_cell = worksheet.cell(row=row, column=6).value     # F列
            product_name_cell = worksheet.cell(row=row, column=11).value  # K列
            transaction_date = worksheet.cell(row=row, column=14).value   # N列
            document_type = worksheet.cell(row=row, column=17).value or '' # Q列
            quantity = worksheet.cell(row=row, column=19).value           # S列
            unit_price = worksheet.cell(row=row, column=22).value or 0    # V列
            currency_cell = worksheet.cell(row=row, column=25).value      # Y列
            amount = worksheet.cell(row=row, column=26).value or 0        # Z列
            
            # 向前填充邏輯
            if customer_id_cell and str(customer_id_cell).strip():
                current_customer_id = str(customer_id_cell).strip()
                
            if product_id_cell and str(product_id_cell).strip():
                current_product_id = str(product_id_cell).strip()
                
            if product_name_cell and str(product_name_cell).strip():
                current_product_name = str(product_name_cell).strip()
                
            if currency_cell and str(currency_cell).strip():
                current_currency = str(currency_cell).strip()
            
            # 檢查是否有關鍵數據
            if transaction_date and quantity is not None and quantity != '':
                # 生成唯一的 transaction_id
                unique_transaction_id = self.generate_unique_transaction_id()
                
                record = {
                    'transaction_id': unique_transaction_id,
                    'customer_id': current_customer_id,
                    'product_id': current_product_id, 
                    'product_name': current_product_name,
                    'transaction_date': transaction_date,
                    'document_type': str(document_type),
                    'quantity': quantity,
                    'unit_price': unit_price,
                    'currency': current_currency,
                    'amount': amount
                }
                
                data.append(record)
        
        logger.info(f"解析完成，共 {len(data)} 筆交易記錄")
        return data
    
    def get_product_is_active(self, product_id: str) -> Optional[bool]:
        """
        從 product_master 表中獲取產品的 is_active 狀態
        
        Args:
            product_id (str): 產品編號
            
        Returns:
            bool: is_active 狀態，如果找不到則返回 None
        """
        try:
            with self.connection.cursor(cursor_factory=RealDictCursor) as cursor:
                query = f"""
                SELECT is_active 
                FROM {self.table_config['product_master']} 
                WHERE product_id = %s
                """
                cursor.execute(query, (product_id,))
                result = cursor.fetchone()
                
                if result:
                    return result['is_active']
                else:
                    logger.warning(f"產品 {product_id} 在 product_master 中未找到")
                    return None
                    
        except Exception as e:
            logger.error(f"查詢產品 {product_id} 的 is_active 狀態失敗: {str(e)}")
            return None
    
    def check_duplicate_record(self, record: Dict) -> Optional[int]:
        """
        檢查是否存在重複記錄
        因為現在每個記錄都有唯一的 transaction_id，所以改為檢查業務邏輯上的重複：
        相同的 product_id, customer_id, transaction_date, document_type, quantity, amount
        
        Args:
            record (dict): 交易記錄
            
        Returns:
            int: 如果找到重複記錄，返回其 id；否則返回 None
        """
        try:
            with self.connection.cursor(cursor_factory=RealDictCursor) as cursor:
                query = f"""
                SELECT id FROM {self.table_config['order_transactions']}
                WHERE product_id = %s
                  AND customer_id = %s
                  AND transaction_date = %s
                  AND document_type = %s
                  AND quantity = %s
                  AND amount = %s
                LIMIT 1
                """
                cursor.execute(query, (
                    record['product_id'],
                    record['customer_id'], 
                    record['transaction_date'],
                    record['document_type'],
                    record['quantity'],
                    record['amount']
                ))
                result = cursor.fetchone()
                
                if result:
                    logger.info(f"發現重複記錄，ID: {result['id']}")
                    return result['id']
                return None
                
        except Exception as e:
            logger.error(f"檢查重複記錄失敗: {str(e)}")
            return None
    
    def update_record(self, db_id: int, record: Dict, is_active: Optional[bool]):
        """
        更新現有記錄
        
        Args:
            db_id (int): 數據庫中記錄的 id
            record (dict): 新的交易記錄
            is_active (bool): 產品是否活躍
        """
        try:
            with self.connection.cursor() as cursor:
                query = f"""
                UPDATE {self.table_config['order_transactions']}
                SET transaction_id = %s,
                    product_name = %s,
                    unit_price = %s,
                    currency = %s,
                    is_active = %s,
                    created_at = %s
                WHERE id = %s
                """
                cursor.execute(query, (
                    record['transaction_id'],
                    record['product_name'],
                    record['unit_price'],
                    record['currency'],
                    is_active,
                    datetime.now(),
                    db_id
                ))
                logger.debug(f"更新記錄 ID: {db_id}")
                
        except Exception as e:
            logger.error(f"更新記錄失敗: {str(e)}")
            raise
    
    def insert_record(self, record: Dict, is_active: Optional[bool]):
        """
        插入新記錄
        
        Args:
            record (dict): 交易記錄
            is_active (bool): 產品是否活躍
        """
        try:
            with self.connection.cursor() as cursor:
                query = f"""
                INSERT INTO {self.table_config['order_transactions']}
                (transaction_id, customer_id, product_id, product_name, 
                 transaction_date, document_type, quantity, unit_price, 
                 currency, amount, is_active, created_at)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """
                cursor.execute(query, (
                    record['transaction_id'],
                    record['customer_id'],
                    record['product_id'],
                    record['product_name'],
                    record['transaction_date'],
                    record['document_type'],
                    record['quantity'],
                    record['unit_price'],
                    record['currency'],
                    record['amount'],
                    is_active,
                    datetime.now()
                ))
                logger.debug(f"插入新記錄 transaction_id: {record['transaction_id']}")
                
        except Exception as e:
            logger.error(f"插入記錄失敗: {str(e)}")
            raise
    
    def upload_data(self, data: List[Dict]) -> Tuple[int, int]:
        """
        上傳數據到數據庫
        
        Args:
            data (list): 交易記錄列表
            
        Returns:
            tuple: (插入記錄數, 更新記錄數)
        """
        if not self.connection:
            raise Exception("數據庫未連接")
        
        inserted_count = 0
        updated_count = 0
        
        try:
            logger.info(f"開始上傳 {len(data)} 筆記錄")
            
            for i, record in enumerate(data):
                # 獲取產品的 is_active 狀態
                is_active = self.get_product_is_active(record['product_id'])
                
                # 檢查是否有重複記錄
                duplicate_id = self.check_duplicate_record(record)
                
                if duplicate_id:
                    # 更新現有記錄
                    self.update_record(duplicate_id, record, is_active)
                    updated_count += 1
                else:
                    # 插入新記錄
                    self.insert_record(record, is_active)
                    inserted_count += 1
                
                # 每處理一定數量記錄就提交一次
                if (i + 1) % APP_CONFIG['batch_size'] == 0:
                    self.connection.commit()
                    logger.info(f"已處理 {i + 1} 筆記錄")
            
            # 最終提交
            self.connection.commit()
            logger.info(f"數據上傳完成 - 插入: {inserted_count} 筆, 更新: {updated_count} 筆")
            
            return inserted_count, updated_count
            
        except Exception as e:
            self.connection.rollback()
            logger.error(f"數據上傳失敗: {str(e)}")
            raise
    
    def process_file(self, file_path: str, delete_month_records: bool = True) -> Tuple[int, int]:
        """
        處理整個流程：解析文件 -> 刪除涉及月份記錄 -> 上傳數據庫
        
        Args:
            file_path (str): Excel 文件路徑
            delete_month_records (bool): 是否刪除涉及月份記錄，默認為 True
            
        Returns:
            tuple: (刪除記錄數, 插入記錄數)
        """
        deleted_count = 0
        
        try:
            # 連接數據庫
            if not self.connect_database():
                raise Exception("無法連接數據庫")
            
            # 1. 先解析 Excel 文件
            logger.info("解析 Excel 文件以提取月份信息...")
            data = self.parse_sales_data(file_path)
            
            # 2. 從數據中提取所有涉及的年月
            months_to_delete = self.extract_months_from_data(data)
            logger.info(f"Excel 中包含的月份: {sorted(list(months_to_delete))}")
            
            # 3. 刪除這些月份的所有記錄（如果需要）
            if delete_month_records and months_to_delete:
                logger.info(f"開始刪除 {len(months_to_delete)} 個月份的記錄...")
                deleted_count = self.delete_records_by_months(months_to_delete)
            
            # 4. 直接插入新記錄
            inserted_count = self.insert_all_records(data)
            
            return deleted_count, inserted_count
            
        finally:
            # 關閉數據庫連接
            self.close_connection()
    
    def insert_all_records(self, data: List[Dict]) -> int:
        """
        直接插入所有記錄（不檢查重複）
        
        Args:
            data (list): 交易記錄列表
            
        Returns:
            int: 插入記錄數
        """
        if not self.connection:
            raise Exception("數據庫未連接")
        
        inserted_count = 0
        
        try:
            logger.info(f"開始插入 {len(data)} 筆記錄")
            
            for i, record in enumerate(data):
                # 獲取產品的 is_active 狀態
                is_active = self.get_product_is_active(record['product_id'])
                
                # 直接插入新記錄
                self.insert_record(record, is_active)
                inserted_count += 1
                
                # 每處理一定數量記錄就提交一次
                if (i + 1) % APP_CONFIG['batch_size'] == 0:
                    self.connection.commit()
                    logger.info(f"已處理 {i + 1} 筆記錄")
            
            # 最終提交
            self.connection.commit()
            logger.info(f"數據插入完成 - 插入: {inserted_count} 筆")
            
            return inserted_count
            
        except Exception as e:
            self.connection.rollback()
            logger.error(f"數據插入失敗: {str(e)}")
            raise
    
    def process_file_without_deletion(self, file_path: str) -> int:
        """
        處理文件但不刪除月份記錄（用於追加數據）
        
        Args:
            file_path (str): Excel 文件路徑
            
        Returns:
            int: 插入記錄數
        """
        _, inserted = self.process_file(file_path, delete_month_records=False)
        return inserted

def main():
    """主函數"""
    file_path = "main/upload_data/test_data/6月銷貨.xlsx"
    
    uploader = SalesDataUploader()
    
    try:
        inserted, updated = uploader.process_file(file_path)
        print(f"處理完成！插入 {inserted} 筆新記錄，更新 {updated} 筆現有記錄")
        
    except FileNotFoundError:
        print(f"錯誤: 找不到文件 {file_path}")
    except Exception as e:
        print(f"錯誤: {str(e)}")
        logger.exception("程序執行出錯")

if __name__ == "__main__":
    main()